#!/usr/bin/perl
# Your name and username@ucsc.edu 
use strict;
use warnings;

#open file
sub ltrim { my $s = shift; $s =~ s/^\s+//; return $s };
my %targets;
my %commands; 
# go through file once, store target with its prereqs and its commands into a hash
# Then, make the target and recursively call its prereqs by looking through the hashtable.
#

sub mtime ($){
	my ($filename) = @_;
	my @stat = stat $filename;
	return @stat ? $stat[9] : undef;
}

sub makeTarget{
	my ($target) = @_;
	my @prereqs;
	my $prereqsExist = 1;
	my $hashValue = $targets{$target};
	#print "my target is: $target\n";
	#print "hash value is: $hashValue --\n";
	if(not (defined ($hashValue))){   
		#print STDOUT "prereq does not exist\n";
		$prereqsExist = 0;
	}
	else{
	 	#print STDOUT "prereq exists\n";
		@prereqs = split " ",$targets{$target};
	}
	
	#for (my $k = 0; $k < @prereqs; ++$k){
	#	print STDOUT "$k: $prereqs[$k], ";
        #}
	#print STDOUT @prereqs;
	if($prereqsExist){
		#print STDOUT "prereq defined\n";
		for (my $j = 0; $j < @prereqs ; ++$j){
		#check if prereq is a file by checking the target hash
		#check time stamp between target and prereq[i] if file
		#if not file makeTarget the prereq
			#print STDOUT "$j: recursive call on: $prereqs[$j]\n";
			if (-e $prereqs[$j]){
				my $fileTime = mtime ($prereqs[$j]);
				my $targetTime = mtime ($target);
				if (defined ($targetTime)){
				if ($fileTime > $targetTime){


				}else{
					#throw an error, target obsolete
				}			}
			}else{
				makeTarget($prereqs[$j]);
			}
		}



	}
	
	#print STDOUT "done making prereqs\n";
	my @execute = split /"\n"/, $commands{$target};
	for (my $i = 0; $i < @execute ; ++$i){
		my @parseExecute = split /\s+/ ,$execute[$i];
	#	for (my $j = 0; $j < @parseExecute; ++$j){
	#		print STDOUT "$j: $parseExecute[$j] ";
#		}
		if($parseExecute[1] eq "@"){
				my $deleteAt = substr($execute[$i], 3);
			system($deleteAt);
		}else{
			my $wor = ltrim($execute[$i]);
			print STDOUT "$wor \n";
			system($execute[$i]);
		}
	}
}

for my $targetName ($ARGV[0]) {
	open my $file, "Makefile" or warn "$0: Makefile: $!\n" and next;
	while (defined (my $line = <$file>)) {
		unless($line =~ /^\s*$/) {
		#	print STDOUT $line;
			chomp($line);
			ltrim($line);
			my @words = split /\s+/, $line;
#			print STDOUT "\n----";
#			for (my $i = 0; $i < @words; ++$i){
#				print "$i: ";
#				print STDOUT $words[$i];
#				print "--";
#			}
			#print "\n";
			if($words[0] ne "#"){
				if($words[1] eq ":"){
					#print STDOUT "here 3";	
					if (@words > 2){
						my @test = @words[2 .. $#words];
						#for (my $k = 0; $k < @test; ++$k){
                                                #       print STDOUT "$k: $test[$k], ";
						#}
						my $testString = join ' ',@test;
						#print STDOUT "Joined string: $testString \n";
						#print STDOUT "\n";
						#print STDOUT "storing this to hash tbl: $words[0]";
						$targets{$words[0]} = $testString;		
                                         	#print STDOUT "targets: $targets{$words[0]}"; 
					}
					my $nextline = <$file>;
					chomp($nextline);
					ltrim($nextline);
					#print STDOUT "nextline is: $nextline";
					while (not ($nextline =~ /^\s*$/)){
					#print STDOUT "nextline is: $nextline\n";
						if (not(defined($commands{$words[0]}))){
							$commands{$words[0]} = $nextline;
						}else{
							$commands{$words[0]} = $commands{$words[0]}."\n".$nextline; 
						}
						$nextline = <$file>;
					}
				}
			}
		#	print ($line, "\n");
		}
	}
	# /\s+/ one or more whitespace.. 		
	# #if words[0] is # ignore line 	
	close $file;	
	#print STDOUT $targetName;
	makeTarget $targetName;	
}
#read lines while defined,
#if line compare to whitespace is true, ignore
#if trimmed and substring(0,1) = # OR use split string and check a[0], ignore


#MACROS
#	makeTarget $targetName; 
